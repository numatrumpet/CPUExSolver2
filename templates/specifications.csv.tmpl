アーキテクチャ名	mimic
バイナリファイルのエンディアン	リトルエンディアン
ROM（命令メモリを格納する領域）サイズ	64KB(固定)
ROMアドレッシング	ワードアドレッシング
RAM（プログラム実行時の作業用領域）サイズ	8.00
RAMアドレッシング	ワードアドレッシング
コメントアウト記号	#
整数レジスタ接頭辞	r
浮動小数レジスタ接頭辞	f
整数レジスタ数	32
浮動小数レジスタ数	32
キャッシュに使う浮動小数レジスタ数	16
ゼロレジスタ	$r0
フレームレジスタ	$r1
ヒープレジスタ	$r2
リンクレジスタ	$r29
1固定レジスタ	$r30
-1固定レジスタ	$r31


命令形式
R	op(6bit)	rs(5bit)	rt(5bit)	rd(5bit)	shamt(5bit)	funct(5bit)
I	op(6bit)	rs(5bit)	rt(5bit)	imm(16bit)
J	op(6bit)	target(26bit)


命令名	説明	命令形式	アセンブリ形式	擬似コード	op						funct
add	たし算	R	add rd, rs, rt	rd <- rs + rt	0	0	0	0	0	0	0	0	0	0	0	0
sub	ひき算	R	sub rd, rs, rt	rd <- rs - rt	0	0	0	0	0	0	0	0	0	0	0	1
mul	かけ算	R	mul rd, rs, rt	rd <- rs * rt	0	0	0	0	0	0	0	0	0	0	1	0
and	論理積	R	and rd, rs, rt	rd <- rs & rt	0	0	0	0	0	0	0	0	1	0	0	1
or	論理和	R	or rd, rs, rt	rd <- rs | rt	0	0	0	0	0	0	0	0	1	0	1	0
nor	論理否定和	R	nor rd, rs, rt	rd <- rs nor rt	0	0	0	0	0	0	0	0	1	0	1	1
xor	排他的論理和	R	xor rd, rs, rt	rd <- rs xor rt	0	0	0	0	0	0	0	0	1	1	0	0
not	ビット反転	R	not rt, rs	rt <- not rs	0	0	0	0	0	0	0	0	1	1	0	1
mvlo	下位16bitに即値代入	I	mvlo rs, imm	rs[0:15] <- imm	0	1	0	0	0	1	
mvhi	上位16bitに即値代入	I	mvhi rs, imm	rs[16:31] <- imm	0	1	0	0	1	0	
addi	たし算	I	addi rt, rs, imm	rt <- rs + imm	0	0	0	1	0	0	
subi	ひき算	I	subi rt, rs, imm	rt <- rs - imm	0	0	0	1	0	1	
muli	かけ算	I	muli rt, rs, imm	rt <- rs * imm	0	0	0	1	1	0	
slli	論理左シフト	I	slli rt, rs, imm	rt <- rs << imm	0	0	1	0	0	0	
srai	算術右シフト	I	srai rt, rs, imm	rt <- rs >> imm	0	0	1	0	1	1	
andi	論理積	I	andi rt, rs, imm	rt <- rs & imm	0	0	1	1	0	1	
ori	論理和	I	ori rt, rs, imm	rt <- rs | imm	0	0	1	1	1	0	
nori	論理否定和	I	nori rt, rs, imm	rt <- rs nor imm	0	0	1	1	1	1	
xori	排他的論理和	I	xori rt, rs, imm	rt <- rs xor imm	0	1	0	0	0	0	
fmov	値の複製	R	fmov frt, frs	frt <- frs	0	0	0	0	1	0	0	0	0	0	0	1
fneg	符号反転	R	fneg frt, frs	frt <- -frs	0	0	0	0	0	1	0	0	0	0	0	0
fmvlo	下位16bitに即値代入	I	fmvlo frs, imm	frs[0:15] <- imm	0	1	0	0	1	1	
fmvhi	上位16bitに即値代入	I	fmvhi frs, imm	frs[16:31] <- imm	0	1	0	1	0	0	
fadd	たし算	R	fadd frd, frs, frt	frd <- frs + frt	0	0	0	0	0	1	0	0	0	0	0	1
fsub	ひき算	R	fsub frd, frs, frt	frd <- frs - frt	0	0	0	0	0	1	0	0	0	0	1	0
fmul	かけ算	R	fmul frd, frs, frt	frd <- frs * frt	0	0	0	0	0	1	0	0	0	0	1	1
fmuln	かけ算して符号反転	R	fmuln frd, frs, frt	frd <- -(frs * frt)	0	0	0	0	0	1	0	0	0	1	0	0
fdiv	わり算	R	fdiv frd, frs, frt	frd <- frs / frt	0	0	0	0	0	1	0	0	0	1	0	1
fsqrt	平方根	R	fsqrt frt, frs	frt <- fsqrt(frs)	0	0	0	0	0	1	0	0	1	0	0	1
itof	intをfloatにキャスト	R	itof frt, rs	frt <- (float)rs	0	0	0	0	1	0	0	0	0	0	1	0
ftoi	floatをintにキャスト	R	ftoi rt, frs	rt <- (int)frs	0	0	0	0	1	0	0	0	0	0	1	1
imovf	バイナリ列をコピー	R	imovf frt, rs	frt <- rs	0	0	0	0	1	0	0	0	0	1	0	0
fmovi	バイナリ列をコピー	R	fmovi rt, frs	rt <- frs	0	0	0	0	1	0	0	0	0	1	0	1
ldi	メモリから整数レジスタへロード	I	ldi rt, rs, imm	rt <- RAM[rs + imm]	1	0	1	0	0	0	
sti	整数レジスタをメモリへストア	I	sti rt, rs, imm	RAM[rs + imm] <- rt	1	0	1	0	0	1	
ldr	メモリから整数レジスタへロード	R	ldr rd, rs, rt	rd <- RAM[rs + rt]	0	0	0	0	0	0	0	0	1	1	1	0
str	整数レジスタをメモリへストア	R	str rd, rs, rt	RAM[rs + rt] <- rd	0	0	0	0	0	0	0	0	1	1	1	1
fldi	メモリから浮動小数レジスタへロード	I	fldi frt, rs, imm	frt <- RAM[rs + imm]	1	0	1	0	1	0	
fsti	浮動小数レジスタをメモリへストア	I	fsti frt, rs, imm	RAM[rs + imm] <- frt	1	0	1	0	1	1	
fldr	メモリから浮動小数レジスタへロード	R	fldr frd, rs, rt	frd <- RAM[rs + rt]	0	0	0	0	0	0	0	1	0	0	0	0
fstr	浮動小数レジスタをメモリへストア	R	fstr frd, rs, rt	RAM[rs + rt] <- frd	0	0	0	0	0	0	0	1	0	0	0	1
beq	等しい	I	beq rs, rt, imm	if rs == rt then goto (pc + imm)	0	1	0	1	1	0	
bne	等しくない	I	bne rs, rt, imm	if rs != rt then goto (pc + imm)	0	1	0	1	1	1	
blt	より小さい	I	blt rs, rt, imm	if rs < rt then goto (pc + imm)	0	1	1	0	0	0	
bgt	より大きい	I	bgt rs, rt, imm	if rs > rt then goto (pc + imm)	0	1	1	0	0	1	
ble	以下	I	ble rs, rt, imm	if rs <= rt then goto (pc + imm)	0	1	1	0	1	0	
bge	以上	I	bge rs, rt, imm	if rs >= rt then goto (pc + imm)	0	1	1	0	1	1	
fbeq	等しい	I	fbeq frs, frt, imm	if frs == frt then goto (pc + imm)	0	1	1	1	0	0	
fbne	等しくない	I	fbne frs, frt, imm	if frs != frt then goto (pc + imm)	0	1	1	1	0	1	
fblt	より小さい	I	fblt frs, frt, imm	if frs < frt then goto (pc + imm)	0	1	1	1	1	0	
fbgt	より大きい	I	fbgt frs, frt, imm	if frs > frt then goto (pc + imm)	0	1	1	1	1	1	
fble	以下	I	fble frs, frt, imm	if frs <= frt then goto (pc + imm)	1	0	0	0	0	0	
fbge	以上	I	fbge frs, frt, imm	if frs >= frt then goto (pc + imm)	1	0	0	0	0	1	
j	ラベルへジャンプ	J	j labelName	goto labelName	0	1	0	1	0	1	
jr	レジスタ値へジャンプ	R	jr rs	goto rs	1	0	0	0	1	0	0	0	0	0	0	0
call	フレームポインタを減らしてリンクしてラベルへジャンプ	J	call labelName	RAM[frame pointer] <- link register; frame pointer--; link register <- pc; goto labelName	1	0	0	1	0	1	
callr	フレームポインタを減らしてリンクしてレジスタ値へジャンプ	R	callr reg	RAM[frame pointer] <- link register; frame pointer--; link register <- pc; goto rs	1	0	0	1	1	0	0	0	0	0	0	0
return	フレームポインタを増やしてリンクレジスタの値へジャンプ	R	return op	RAM[frame pointer] <- link register; frame pointer++; goto link register	1	0	0	1	1	1	0	0	0	0	0	0
inputb	1byte読み込み	R	inputb rs	rs <- ReadByte()	0	0	0	0	1	1	0	0	0	0	0	0
outputb	1byte書き出し	R	outputb rs	WriteByte(rs & 0xf)	0	0	0	0	1	1	0	0	0	0	1	1
halt	プログラムを終了	R	halt  		0	0	0	0	1	1	0	0	0	1	1	0
